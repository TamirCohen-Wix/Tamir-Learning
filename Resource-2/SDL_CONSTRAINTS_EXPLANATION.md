# SDL Constraints Explanation

Based on the SDL README and your project code, here's how constraints work in your project:

## Important Clarification

**SDL README does NOT mention location constraints.** The `constraint_filter` you're seeing is **NOT from SDL itself**, but from the **Nile Search integration** that works with SDL.

## Types of Constraints in SDL

### 1. **Authorization Constraints** (Manual - from SDL README)
These are constraints you **explicitly provide** to SDL operations like `get`, `update`, `patch`, `delete`, and `query`. They are used to ensure that operations only succeed when certain authorization conditions are met.

**Example from README:**
```scala
// Query with Authorization Constraint
sdl.query.withAuthorizationConstraint(equal("userId", expectedUserId)).execute()

// Update with Authorization Constraint
sdl.update.single(entity)
  .withAuthorizationConstraint(Some(equal("userId", expectedUserId)))
  .execute()
```

**In your project:** You're NOT using manual authorization constraints in your code. These would be explicitly added by you.

### 2. **Constraint Filters** (Automatic - from Nile Search Integration)
These are **automatically generated by Nile Search infrastructure** (not SDL) when performing search operations. They are NOT manually added by you and are NOT documented in SDL README.

## How Constraint Filters Are Built (Nile Search Integration)

### Based on What?

Based on your logs, Nile Search integration builds constraint filters based on:

1. **Authorization Context from `CallScope`**
   - The `callScope` (implicit parameter) contains the authorization information
   - This includes user identity, permissions, and potentially location access

2. **Token Type Detection**
   - **Server-to-Server tokens** (e.g., `SRV.JWS`): **NO constraint_filter is added**
   - **User session tokens**: **constraint_filter MAY be added** if user has location restrictions

3. **User's Location Access Permissions** (if present in token)
   - Nile Search extracts location access information from the authorization token
   - If user has location restrictions, it generates constraint_filter
   - If user has NO location restrictions, constraint_filter is likely NOT added

4. **Domain Entity Field Structure**
   - Nile Search uses the **domain entity field paths** (camelCase) to build the constraint filter
   - In your case: `locationOptions.specificLocationOptions.businessLocations.locationId`

### How It Works

When you call:
```scala
sdl.search.search(search).execute()  // in SdlHandler.searchResources()
```

The flow is:
1. **SDL** passes the search request to **Nile Search integration**
2. **Nile Search integration** extracts `CallScope` (passed implicitly)
3. **Nile Search integration** analyzes authorization context:
   - Checks if it's a user session token (vs server-to-server token)
   - If server token → **NO constraint_filter** (as seen in your valid request)
   - If user token → Checks for location restrictions in token
4. **Nile Search integration** generates constraint filter (if needed):
   - **If user has location restrictions**: Generates constraint_filter like:
   ```json
   {
     "$or": [
       {
         "locationOptions.specificLocationOptions.businessLocations.locationId": {
           "$hasSome": ["21f75877-47c2-411a-ab69-f3d10b7b9b33"]
         }
       },
       {
         "locationOptions.availableInAllLocations": {
           "$eq": true
         }
       }
     ]
   }
   ```
   - **If user has NO location restrictions**: Likely NO constraint_filter is added
5. **Adds to Search Request**
   - The constraint_filter is added to the `SearchRequest.properties` as `constraint_filter`
   - This happens **before** the request is sent to Nile Search backend

### Why It Happens

Nile Search integration builds constraint filters to:
- **Enforce location-based access control** - Users with location restrictions should only see resources available at locations they have access to
- **Security** - Prevent users from accessing resources they shouldn't see
- **Multi-location support** - Support businesses with multiple locations where users may have access to specific locations only

### What If User Doesn't Have Location Restrictions?

Based on your logs:
- **Server token (SRV.JWS)**: No constraint_filter → Works correctly
- **User token with location restrictions**: Has constraint_filter → Fails due to field path mismatch
- **User token WITHOUT location restrictions**: Likely **NO constraint_filter** → Should work correctly

**The constraint_filter is only added when:**
1. It's a user session token (not server token)
2. AND the user has location restrictions in their authorization token

### The Problem in Your Project

**Field Path Mismatch:**

Nile Search integration generates constraint_filter using **domain entity field paths** (camelCase):
- `locationOptions.specificLocationOptions.businessLocations.locationId`
- `locationOptions.availableInAllLocations`

But Nile Search expects **WQL field paths** (snake_case) as defined in your proto:
- `single_resource.location_options.specific_location_options.business_locations.location_id`
- `single_resource.location_options.available_in_all_locations`

### Why the Mismatch?

1. **Field Path Translation Happens at Different Stages**
   - `ResourceTranslator` (line 192-206) translates between API and domain
   - But constraint_filter is generated by Nile Search integration **before** this translation
   - Or it uses a different translation mechanism that doesn't account for WQL field paths

2. **Nile Search Integration Uses Domain Field Paths**
   - Nile Search constraint_filter generator uses the domain entity structure directly
   - It doesn't know about the WQL field path format required by Nile Search backend

3. **Missing Translation Step**
   - The constraint_filter field paths need to be translated from domain paths to WQL paths
   - This translation should happen before sending to Nile Search

## Configuration in Your Project

Your SDL is configured in `ResourcesService.apply()` (line 560):
```scala
searchOptions = SearchOptions(contextBuilder.config.appSecret),
```

This `SearchOptions` comes from `generators.modules.search.share.SearchOptions` (external module) and likely contains configuration for how SDL integrates with Nile Search.

## Summary

**Nile Search integration builds constraint filters:**
- **Automatically** when performing search operations (NOT by SDL itself)
- **Only when** user session token has location restrictions
- **Based on** authorization context from `CallScope`
- **Using** domain entity field paths (camelCase)
- **To enforce** location-based access control

**When constraint_filter is NOT added:**
- Server-to-server tokens (SRV.JWS) → No constraint_filter
- User tokens without location restrictions → Likely no constraint_filter

**The issue:** When constraint_filter IS added, it uses domain field paths (camelCase), but Nile Search expects WQL field paths (snake_case with `single_resource.` prefix).

**The fix needed:** Ensure constraint_filter field paths are translated from domain paths to WQL paths before being sent to Nile Search backend.

## Important Note

**SDL README does NOT document location constraints or constraint_filter.** This is a feature of the Nile Search integration layer, not SDL itself. The constraint_filter behavior is inferred from your logs showing the difference between server tokens (no constraint) and user tokens (with constraint).

